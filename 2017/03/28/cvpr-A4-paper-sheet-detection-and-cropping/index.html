<!doctype html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.png?v=5.1.0" />






<meta name="description" content="Function similar to Document Scanner. Given images of A4 paper sheets, output paper sheets’ four corners as well as four edges and their equations. Then crop the background and leave the paper sheet i">
<meta property="og:type" content="article">
<meta property="og:title" content="[CVPR] A4 Paper Sheet Detection and Cropping with Hough Transform and Warping">
<meta property="og:url" content="http://yoursite.com/2017/03/28/cvpr-A4-paper-sheet-detection-and-cropping/index.html">
<meta property="og:site_name" content="HYPJUDY">
<meta property="og:description" content="Function similar to Document Scanner. Given images of A4 paper sheets, output paper sheets’ four corners as well as four edges and their equations. Then crop the background and leave the paper sheet i">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/2.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/2_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/2_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/14.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/14_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/14_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/R_theta_line.jpg">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/blur.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/gradient.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/hough_space.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/hough_space2.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/4_out.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/forward_mapping.jpg">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/bilinear_filter.jpg">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/0.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/0_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/0_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/1.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/1_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/1_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/13.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/13_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/13_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/3.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/3_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/3_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/4_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/4_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/5.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/5_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/5_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/6.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/6_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/6_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/7.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/7_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/7_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/12.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/12_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/12_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/9.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/9_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/9_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/10.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/10_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/10_A4.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/15.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/15_marked.bmp">
<meta property="og:image" content="http://yoursite.com/images/paper-sheet/15_A4.bmp">
<meta property="og:updated_time" content="2017-04-26T12:30:38.936Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[CVPR] A4 Paper Sheet Detection and Cropping with Hough Transform and Warping">
<meta name="twitter:description" content="Function similar to Document Scanner. Given images of A4 paper sheets, output paper sheets’ four corners as well as four edges and their equations. Then crop the background and leave the paper sheet i">
<meta name="twitter:image" content="http://yoursite.com/images/paper-sheet/2.bmp">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":20},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/03/28/cvpr-A4-paper-sheet-detection-and-cropping/"/>





  <title> [CVPR] A4 Paper Sheet Detection and Cropping with Hough Transform and Warping | HYPJUDY </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-96132499-1', 'auto');
  ga('send', 'pageview');
</script>











  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HYPJUDY</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">What I cannot create, I do not understand.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/28/cvpr-A4-paper-sheet-detection-and-cropping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="HYPJUDY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HYPJUDY">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                [CVPR] A4 Paper Sheet Detection and Cropping with Hough Transform and Warping
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-28T18:55:53+08:00">
                2017-03-28
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/03/28/cvpr-A4-paper-sheet-detection-and-cropping/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/03/28/cvpr-A4-paper-sheet-detection-and-cropping/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Function similar to Document Scanner. Given images of A4 paper sheets, output paper sheets’ four corners as well as four edges and their equations. Then crop the background and leave the paper sheet in proper position and standard scaling. We can do this in three steps. Firstly, detect edges with hough transform. Then store the corners in order. Lastly, applying a perspective transform to warp the image.</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/2.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/2_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/2_A4.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/14.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/14_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/14_A4.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div>
<a id="more"></a>
<p>★<a href="https://github.com/HYPJUDY/A4-paper-sheet-detection-and-cropping" target="_blank" rel="external"><strong>Source codes and images here</strong></a></p>
<p>Here’s a <a href="http://www.pyimagesearch.com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/" target="_blank" rel="external">Document Scanner tutorial</a> implemented with OpenCV(without all theory details).</p>
<h1 id="Edge-Detection-with-Hough-Transform"><a href="#Edge-Detection-with-Hough-Transform" class="headerlink" title="Edge Detection with Hough Transform"></a>Edge Detection with Hough Transform</h1><p>★Here’s an excellent c++ example part of the CImg Library project: <a href="https://github.com/dtschump/CImg/blob/master/examples/hough_transform2d.cpp" target="_blank" rel="external">Computation of the Hough Transform</a> <em>Illustrate the computation of the Hough transform to detect lines in 2D images. Provide also simple user interface to select and display lines</em></p>
<h2 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h2><blockquote>
<p>The purpose of the Hough transform is to address this problem by making it possible to perform groupings of edge points into object candidates by performing an explicit voting procedure over a set of parameterized image objects (Shapiro and Stockman, 304).</p>
</blockquote>
<p>Reference: <a href="https://en.wikipedia.org/wiki/Hough_transform#Using_the_gradient_direction_to_reduce_the_number_of_votes" target="_blank" rel="external">wiki</a></p>
<p>The Hough transform is a feature extraction technique. The simplest case of Hough transform is detecting straight lines. In general, the straight line $y = mx + b$ can be represented as a point $(b, m)$ in the parameter space. However, vertical lines pose a problem. They would give rise to unbounded values of the slope parameter m. Thus, for computational reasons, Duda and Hart[5] proposed the use of the <a href="https://en.wikipedia.org/wiki/Hesse_normal_form" target="_blank" rel="external">Hesse normal form</a></p>
<p>$$rho = x\cos \theta + y\sin \theta$$</p>
<p>where $r$ is the distance from the origin to the closest point on the straight line, and $\theta$ is the angle between the $x$ axis and the line connecting the origin with that closest point.</p>
<p>Even if lines are not vertical, parameter $m$ and $b$ can get rather large which is hard to define their bounds. The transform is necessary.</p>
<p><img src="/images/paper-sheet/R_theta_line.jpg" alt="R_theta_line.jpg"><br>It is therefore possible to associate with each line of the image a pair $(r,\theta )$. The $(r,\theta )$ plane is sometimes referred to as <strong>Hough space</strong> for the set of straight lines in two dimensions. </p>
<p>Given a single point in the plane, then the set of all straight lines going through that point corresponds to a sinusoidal curve in the $(r,\theta )$ plane, which is unique to that point. A set of two or more points that form a straight line will produce sinusoids which cross at the $(r,\theta )$ for that line. Thus, the problem of <strong>detecting collinear points</strong> can be converted to the problem of <strong>finding concurrent curves</strong>.</p>
<p>Also see: <a href="https://cn.mathworks.com/help/images/ref/hough.html#buwgokq-6" target="_blank" rel="external">MathWorks: hough</a>.</p>
<h2 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h2><p>Reference: <a href="http://blog.csdn.net/qq_26898461/article/details/50995609" target="_blank" rel="external">Leo’s blog</a></p>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><p>The <code>hough_space</code> is a parameter space matrix whose columns and rows correspond to $angle$ and $rho$ values respectively. Its width range represents the possible degrees of each angle of the straight line passing through a point. Its height range represents the largest possible of $rho$ which is the distance of two diagonal corners in image. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">rgb_img.load_bmp(filePath);</div><div class="line">w = rgb_img.width();</div><div class="line">h = rgb_img.height();</div><div class="line">gray_img = gradients = CImg&lt;<span class="keyword">double</span>&gt;(w, h, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">hough_space = CImg&lt;<span class="keyword">double</span>&gt;(<span class="number">180</span>, distance(w, h), <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<h3 id="Pre-treatment"><a href="#Pre-treatment" class="headerlink" title="Pre-treatment"></a>Pre-treatment</h3><ul>
<li><strong>Convert rgb image to grayscale image</strong> because the color information helps little here.</li>
<li><strong>Blur the grayscale image</strong> helps a lot in noise reduction and focusing on the real edges.</li>
<li><strong>Get intensity gradient magnitude of grayscale image</strong> for edge detection. For each pixel in grayscale image, it’s intensity gradient magnitude is calculated by $\sqrt{gradX^2 + gradY^2}$. I use one dimensional filter (next pixel value minus previous pixel value in x-axis and y-axis for $gradX$ and $gradY$ respectively).</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rgb2gray();</div><div class="line">gray_img.blur(BLUR_SIGMA); <span class="comment">// noise reduction</span></div><div class="line">getGradient();</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Euclidean distance / Pythagorean Theorem */</span></div><div class="line"><span class="keyword">double</span> Hough::distance(<span class="keyword">double</span> diff_x, <span class="keyword">double</span> diff_y) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(diff_x * diff_x + diff_y * diff_y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* RGB to grayscale transformation */</span></div><div class="line"><span class="keyword">void</span> Hough::rgb2gray() &#123;</div><div class="line">    cimg_forXY(rgb_img, x, y) &#123;</div><div class="line">        <span class="keyword">int</span> r = rgb_img(x, y, <span class="number">0</span>);</div><div class="line">        <span class="keyword">int</span> g = rgb_img(x, y, <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> b = rgb_img(x, y, <span class="number">2</span>);</div><div class="line">        gray_img(x, y) = <span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* get intensity gradient magnitude for edge detection */</span></div><div class="line"><span class="keyword">void</span> Hough::getGradient() &#123;</div><div class="line">    CImg_3x3(I, <span class="keyword">double</span>);</div><div class="line">    cimg_for3x3(gray_img, x, y, <span class="number">0</span>, <span class="number">0</span>, I, <span class="keyword">double</span>) &#123;</div><div class="line">        <span class="comment">// one-dimension filter better than 2D(sobel etc)</span></div><div class="line">        gradients(x, y) = distance(Inc - Ipc, Icp - Icn);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CImg function usage: <a href="http://cimg.eu/reference/group__cimg__loops.html" target="_blank" rel="external">Using Image Loops</a><br><strong><code>CImg_3x3(I,type)</code></strong> : Define a 3x3 neighborhood named <code>I</code>, of type <code>type</code>. Actually, <code>I</code> is a generic name for the neighborhood. In fact, these macros declare a set of new variables. </p>
<p>For instance, defining a 3x3 neighborhood <code>CImg_3x3(I,float)</code> declares 9 different float variables <code>Ipp</code>,<code>Icp</code>,<code>Inp</code>,<code>Ipc</code>,<code>Icc</code>,<code>Inc</code>,<code>Ipn</code>,<code>Icn</code>,<code>Inn</code> which correspond to each pixel value of a 3x3 neighborhood. Variable indices are <code>p</code>,<code>c</code> or <code>n</code>, and stand respectively for <strong>‘previous’</strong>, <strong>‘current’</strong> and <strong>‘next’</strong>. First indice denotes the x-axis, second indice denotes the y-axis. Then, the names of the variables are directly related to the position of the corresponding pixels in the neighborhood.</p>
<ul>
<li><code>Ipp = img(x-1,y-1)</code></li>
<li><code>Icn = img(x,y+1)</code></li>
<li><code>Inp = img(x+1,y-1)</code></li>
</ul>
<p><strong><code>cimg_for3x3x3(img,x,y,z,c,I,T)</code></strong> : Loop along the (x,y,z)-axes using a centered 3x3x3 neighborhood.</p>
<h2 id="Transform-to-Hough-Space"><a href="#Transform-to-Hough-Space" class="headerlink" title="Transform to Hough Space"></a>Transform to Hough Space</h2><p>The elements in the <code>hough_space</code> represent accumulator cells. Initially, the value in each cell is zero. Then, for each pixel at $(x,y)$ with strong gradient (larger than <code>GRAD_THRESHOLD</code>), $rho$ is calculated for every $angle$ between 0 and 180 degrees(we can <a href="#Improvement">narrow this range</a> for improvement), and $rho$ is calculated for every $theta$. $rho$ is rounded off to the nearest allowed row in <code>hough_space</code>. </p>
<p>If $rho$ is valid, we look for the accumulator’s bin that the parameters $(angle,rho)$ fall into, and <strong>increment the value of that bin</strong>. </p>
<p>At the end of this procedure, a value of $Q$ in <code>hough_space(a, r)</code> means that $Q$ points in the xy-plane lie on the line specified by $angle(a)$ and $rho(r)$. Peak values in the <code>hough_space</code> represent potential lines in the input image.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Transform points in parameter space to hough space */</span></div><div class="line"><span class="keyword">void</span> Hough::houghTransform() &#123;</div><div class="line">    cimg_forXY(gradients, x, y) &#123;</div><div class="line">        <span class="comment">// consider only strong edges, </span></div><div class="line">        <span class="comment">// also helps to reduce the number of votes</span></div><div class="line">        <span class="keyword">if</span> (gradients(x, y) &gt; GRAD_THRESHOLD) &#123;</div><div class="line">            cimg_forX(hough_space, angle) &#123;</div><div class="line">                <span class="keyword">double</span> theta = <span class="number">1.0</span> * angle * cimg::PI / <span class="number">180.0</span>;</div><div class="line">                <span class="keyword">int</span> rho = (<span class="keyword">int</span>)(x*<span class="built_in">cos</span>(theta) + y*<span class="built_in">sin</span>(theta));</div><div class="line">                <span class="keyword">if</span> (rho &gt;= <span class="number">0</span> &amp;&amp; rho &lt; hough_space.height())</div><div class="line">                    ++hough_space(angle, rho);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Looking-for-Local-Maxima-in-Hough-Space"><a href="#Looking-for-Local-Maxima-in-Hough-Space" class="headerlink" title="Looking for Local Maxima in Hough Space"></a>Looking for Local Maxima in Hough Space</h3><p>By finding the bins with the <strong>highest values</strong>, typically by looking for <strong>local maxima in the accumulator space</strong>, the most likely lines can be extracted, and their (approximate) geometric definitions read off. (Shapiro and Stockman, 304)</p>
<p>In order to find these peaks, I apply <code>threshold</code> of the form (modify from <a href="http://www.xueshu.com/xxgcdxxb/201002/11949938.html" target="_blank" rel="external">this paper</a>)</p>
<p>$$floor(maxVal/Q)$$</p>
<p><code>maxVal</code> is the max value in the accumulator space <code>hough_space</code>, <code>Q</code> is used to adjust threshold. In the paper, $Q=\sqrt 2$, but I set $Q=3$ in my code so that more than three local maxima can be filtered out in all test images. It’s fine that more than 4 local maxima are filtered out because we can easily pick the four brighest(largest pixel value) points which correspond to four edges of a paper sheet.<br>By setting value in <code>hough_space</code> smaller than <code>threshold</code> to zero(black) we can clearly see how many local maxima are filtered out.</p>
<p>By the way, a good form of threshold saves you from adjusting parameters for each image.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Compare function for HoughEdge sort.</span></div><div class="line">The strongest edge rank first. */</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_edges</span><span class="params">(HoughEdge e1, HoughEdge e2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> e1.val &gt; e2.val;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Find out four edges of paper sheet in parameter space </span></div><div class="line">*  =&gt; Get four clusters with the highest values and </div><div class="line">*  select the brighest point from each of them.</div><div class="line">*/</div><div class="line"><span class="keyword">void</span> Hough::getHoughEdges() &#123;</div><div class="line">    <span class="keyword">int</span> maxVal = hough_space.max();</div><div class="line">    <span class="keyword">int</span> threshold = <span class="built_in">floor</span>(maxVal / Q);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; maxVal &lt;&lt; <span class="string">" "</span> &lt;&lt; threshold &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    cimg_forXY(hough_space, angle, rho) &#123;</div><div class="line">        <span class="keyword">int</span> val = hough_space(angle, rho);</div><div class="line">        <span class="keyword">if</span> (val &lt; threshold) &#123;</div><div class="line">            hough_space(angle, rho) = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            HoughEdge hough_edge(angle, rho, val);</div><div class="line">            <span class="keyword">bool</span> is_new_corner = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hough_edges.size(); ++i) &#123;</div><div class="line">                <span class="keyword">if</span> (distance(hough_edges[i].angle - angle,</div><div class="line">                    hough_edges[i].rho - rho) &lt; SCOPE) &#123;</div><div class="line">                    is_new_corner = <span class="literal">false</span>;</div><div class="line">                    <span class="comment">// compare with the other value in this cluster</span></div><div class="line">                    <span class="keyword">if</span> (val &gt; hough_edges[i].val) &#123;</div><div class="line">                        hough_edges[i] = hough_edge; <span class="comment">// update</span></div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (is_new_corner) hough_edges.push_back(hough_edge);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (hough_edges.size() &gt; <span class="number">4</span>) &#123; <span class="comment">// filter out the four strongest edges</span></div><div class="line">        sort(hough_edges.begin(), hough_edges.end(), cmp_edges);</div><div class="line">        <span class="keyword">while</span> (hough_edges.size() &gt; <span class="number">4</span>) hough_edges.pop_back();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hough_edges.size() &lt; <span class="number">4</span>) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR: Please set parameter Q larger in file \</span></div><div class="line">            'hough_transform.h' to filter out four edges!" &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Lines"><a href="#Find-Lines" class="headerlink" title="Find Lines"></a>Find Lines</h3><p>Transform points in hough space to lines in parameter space.</p>
<p>$$m=-\frac {\cos \theta}{\sin \theta}$$<br>$$b=-\frac {rho}{\sin \theta}$$  </p>
<p>Notice the case of line perpendicular to x axis:</p>
<p>$$x=rho$$</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Transform the points in hough space to lines in parameter space */</span></div><div class="line"><span class="keyword">void</span> Hough::getLines() &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hough_edges.size(); ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (hough_edges[i].angle == <span class="number">0</span>) &#123; <span class="comment">// perpendicular to x axis</span></div><div class="line">            lines.push_back(Line(<span class="number">0</span>, <span class="number">0</span>, hough_edges[i].rho));</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">double</span> theta = <span class="number">1.0</span> * hough_edges[i].angle * cimg::PI / <span class="number">180.0</span>;</div><div class="line">        <span class="keyword">double</span> m = -<span class="built_in">cos</span>(theta) / <span class="built_in">sin</span>(theta);</div><div class="line">        <span class="keyword">double</span> b = <span class="number">1.0</span> * hough_edges[i].rho / <span class="built_in">sin</span>(theta);</div><div class="line">        lines.push_back(Line(m, b));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Find-Corners"><a href="#Find-Corners" class="headerlink" title="Find Corners"></a>Find Corners</h3><p>Since the lines returned do not contain any length information, we have to find the end points of each line by calculating the intersections (the corners too) of two lines. Normally,</p>
<p>$$<br>\begin{cases}<br>y=m0x+b0 \\<br>y=m1x+b1<br>\end{cases}<br>$$</p>
<p>=&gt;</p>
<p>$$<br>\begin{cases}<br>x=\frac{b1-b0}{m0-m1} \\<br>y==m0*x+b0=m1*x+b1=(m0*x+b0+m1*x+b1)/2<br>\end{cases}<br>$$</p>
<p>Also take vertical lines into consideration in the following code.</p>
<p>The following code is a little redundant which calculates each intersection point twice and have to average two version of <code>y</code> for the identical value. Cleaner and neater code are welcome to share!</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Get four corners of paper sheet by calculate </span></div><div class="line">*  the intersections of four lines. */</div><div class="line"><span class="keyword">void</span> Hough::getCorners() &#123;</div><div class="line">    <span class="keyword">int</span> x, y;</div><div class="line">    <span class="keyword">double</span> m0, m1, b0, b1;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.size(); ++i) &#123; <span class="comment">// for each line i</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lines.size(); ++j) &#123; <span class="comment">// intersect with line j</span></div><div class="line">            <span class="keyword">if</span> (j == i || lines[i].end_point_num &gt;= <span class="number">2</span> <span class="comment">// at most two end points</span></div><div class="line">                || lines[i].dist_o &gt; <span class="number">0</span> &amp;&amp; lines[j].dist_o &gt; <span class="number">0</span>)  <span class="comment">// both vertical</span></div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            m0 = lines[i].m;</div><div class="line">            b0 = lines[i].b;</div><div class="line">            m1 = lines[j].m;</div><div class="line">            b1 = lines[j].b;</div><div class="line">            <span class="keyword">if</span> (lines[i].dist_o &gt; <span class="number">0</span>) &#123; <span class="comment">// line i vertical</span></div><div class="line">                x = lines[i].dist_o;</div><div class="line">                y = m1 * x + b1;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lines[j].dist_o &gt; <span class="number">0</span>) &#123; <span class="comment">// line j vertical</span></div><div class="line">                x = lines[j].dist_o;</div><div class="line">                y = m0 * x + b0;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123; <span class="comment">// not vertical</span></div><div class="line">                <span class="keyword">double</span> <span class="number">_</span>x = (b1 - b0) / (m0 - m1);</div><div class="line">                x = <span class="keyword">int</span>(<span class="number">_</span>x);</div><div class="line">                <span class="comment">// !! Use higher precision _x but not x to calculate y</span></div><div class="line">                y = (m0 * <span class="number">_</span>x + b0 + m1 * <span class="number">_</span>x + b1) / <span class="number">2</span>; <span class="comment">// ensure align at one point</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">/* Sometimes the intersects of lines are out of image bound</span></div><div class="line">            *  due to part of paper sheet image or not well aligned lines.</div><div class="line">            *  Setting them to the border of image can solve this</div><div class="line">            *  problem to some extent. */</div><div class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> - D &amp;&amp; x &lt; w + D &amp;&amp; y &gt;= <span class="number">0</span> - D &amp;&amp; y &lt; h + D) &#123;</div><div class="line">                <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= w) x = w - <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (y &lt; <span class="number">0</span>) y = <span class="number">0</span>; <span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= h) y = h - <span class="number">1</span>;</div><div class="line">                <span class="keyword">if</span> (lines[i].end_point_num == <span class="number">0</span>) &#123; <span class="comment">// first end point</span></div><div class="line">                    lines[i].x0 = x;</div><div class="line">                    lines[i].y0 = y;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (lines[i].end_point_num == <span class="number">1</span>) &#123; <span class="comment">// second end point</span></div><div class="line">                    lines[i].x1 = x;</div><div class="line">                    lines[i].y1 = y;</div><div class="line">                &#125;</div><div class="line">                corners.push_back(Point(x, y));</div><div class="line">                ++lines[i].end_point_num;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Display-Corners-and-Lines"><a href="#Display-Corners-and-Lines" class="headerlink" title="Display Corners and Lines"></a>Display Corners and Lines</h3><p>Lastly, draw and print corners and lines in original rgb image.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* draw and print corners and lines in original image */</span></div><div class="line"><span class="keyword">void</span> Hough::displayCornersAndLines() &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lines.size(); ++i) &#123;</div><div class="line">        <span class="comment">// draw</span></div><div class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> color_red[] = &#123; <span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</div><div class="line">        <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> color_yellow[] = &#123; <span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span> &#125;;</div><div class="line">        rgb_img.draw_line(lines[i].x0, lines[i].y0,</div><div class="line">            lines[i].x1, lines[i].y1, color_red);</div><div class="line">        rgb_img.draw_circle(lines[i].x0, lines[i].y0, <span class="number">5</span>, color_yellow);</div><div class="line">        rgb_img.draw_circle(lines[i].x1, lines[i].y1, <span class="number">5</span>, color_yellow);</div><div class="line"></div><div class="line">        <span class="comment">// print</span></div><div class="line">        <span class="keyword">if</span> (lines[i].dist_o &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Line "</span> &lt;&lt; i &lt;&lt; <span class="string">": x = "</span> &lt;&lt; lines[i].dist_o &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">char</span> op = lines[i].b &gt; <span class="number">0</span> ? <span class="string">'+'</span> : <span class="string">'-'</span>;</div><div class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Line "</span> &lt;&lt; i &lt;&lt; <span class="string">": y = "</span> &lt;&lt; lines[i].m</div><div class="line">                &lt;&lt; <span class="string">"x "</span> &lt;&lt; op &lt;&lt; <span class="built_in">abs</span>(lines[i].b) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Two end points of line "</span>&lt;&lt; i &lt;&lt; <span class="string">": ("</span> &lt;&lt; lines[i].x0 &lt;&lt;</div><div class="line">            <span class="string">", "</span> &lt;&lt; lines[i].y0 &lt;&lt; <span class="string">"), ("</span> &lt;&lt; lines[i].x1 &lt;&lt;</div><div class="line">            <span class="string">", "</span> &lt;&lt; lines[i].y1 &lt;&lt; <span class="string">")"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="A-Typical-Example"><a href="#A-Typical-Example" class="headerlink" title="A Typical Example"></a>A Typical Example</h2><p>From left to right, images of first row are the <code>rgb_img</code>, <code>gray_img.blur(BLUR_SIGMA)</code> and <code>gradients</code>; images of second row are <code>hough_space</code> after <code>houghTransform()</code>, <code>hough_space</code> after <code>getHoughEdges()</code> and <code>rgb_img</code> with detected lines and corners respectively.<br><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/4.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/blur.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/gradient.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/hough_space.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/hough_space2.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/4_out.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div></p>
<ul>
<li>We can see that process of blurring weaks the handwriting and edge of table a lot.</li>
<li>Contour of paper sheet is extracted after <code>getGradient()</code>.</li>
<li>Performing <code>houghTransform()</code>, we get a beautiful Hough space graph which is stored in matrix <code>hough_space</code>. Its cell value represents the number of curves through any point. Higher cell values are rendered brighter. The four distinctly bright spots are the Hough parameters of the four lines.</li>
<li>In <code>getHoughEdges()</code> function, we extract them by applying threshold.</li>
<li>From these spots’ positions, <code>angle</code> and distance from image center(<code>rho</code>) of the four lines in the input image can be determined. Then four lines of the form $y=mx+b$ and their intersections can be determined. Here’s the output indicating line equations and corner coordinates.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Line 0: x = 83</div><div class="line">Two end points of line 0: (83, 100), (83, 464)</div><div class="line">Line 1: y = 0.0699268x +94.2295</div><div class="line">Two end points of line 1: (83, 100), (331, 118)</div><div class="line">Line 2: y = -28.6363x +9598.99</div><div class="line">Two end points of line 2: (331, 118), (319, 455)</div><div class="line">Line 3: y = -0.0699268x +470.145</div><div class="line">Two end points of line 3: (83, 464), (319, 455)</div></pre></td></tr></table></figure>
<h1 id="Image-Warping-and-Perspective-Transform-of-2D-Image"><a href="#Image-Warping-and-Perspective-Transform-of-2D-Image" class="headerlink" title="Image Warping and Perspective Transform of 2D Image"></a>Image Warping and Perspective Transform of 2D Image</h1><h2 id="Theory-1"><a href="#Theory-1" class="headerlink" title="Theory"></a>Theory</h2><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Paper(in chinese): <a href="http://www.opticsjournal.net/Articles/Abstract?aid=OJ1208150001723z6B9E" target="_blank" rel="external">Perspective Image Rectification Based on Improved Hough Transformation and Perspective Transformation</a><br><a href="https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/warp/warp.pdf" target="_blank" rel="external">Image Warping Slides</a> by Thomas Funkhouser.<br>CVPR Slides by Kun Zeng, SYSU.</p>
<p>Futher reading: <a href="http://davis.wpi.edu/~matt/courses/morph/2d.htm" target="_blank" rel="external">2D Image Morphing Algorithms</a></p>
<h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><p><strong>Image filtering:</strong> change <strong>range</strong> of image.<br><strong>Image warping:</strong> change <strong>domain</strong> of image. Manipulating pixel positions.<br><strong>Source Image:</strong> Image to be used as the reference. The geometry of this image is no changed.<br><strong>Target Image:</strong> this image is obtained by transforming the reference image.<br><strong>(x,y):</strong> coordinates of points in the reference image<br><strong>(u,v):</strong> coordinates of points in the target image<br><strong>f,g or F,G:</strong> x and y component of a transformation function<br><strong>Control points:</strong> Unique points in the reference and target images. The coordinates of corresponding control points in images are used to determine a transformation function.<br><strong>A Transformation Function:</strong> used to compute the corresponding points<br><strong>Perspective/Projective Transform:</strong> Allow a square to be distorted into any quadrilateral. Inverse is also projective. Good when controlling a warp with quadrilaterals, since 4 points in 2D determine the 8 degrees of freedom.</p>
<h3 id="Perspective-Transform-Parameters-Calculation"><a href="#Perspective-Transform-Parameters-Calculation" class="headerlink" title="Perspective Transform Parameters Calculation"></a>Perspective Transform Parameters Calculation</h3><p>After obtaining four edges and corners of paper sheet, the next step is mapping. A transformation describes the destination <code>(u,v)</code> for every location <code>(x,y)</code> in the source in this case (quadrilateral-&gt;quadrilateral) is perspective transform.</p>
<p>$$u=\frac{ax+by+c}{mx+ly+1}, v=\frac{dx+ey+f}{mx+ly+1}$$</p>
<p>The above equations can also be rewritten as:</p>
<p>$$\begin{bmatrix}u\\v\\ \end{bmatrix} = \begin{bmatrix}x&amp;y&amp;1&amp;0&amp;0&amp;0&amp;-ux&amp;-uy\\0&amp;0&amp;0&amp;x&amp;y&amp;1&amp;-vx&amp;-vy\\ \end{bmatrix} \begin{bmatrix}a\\b\\c\\d\\e\\f\\m\\l\\ \end{bmatrix}$$</p>
<p>In which $a$, $b$, $x$, $d$, $e$, $f$, $m$, $l$ are parameters of perspective transform. Eight equations are need to find out these eight parameters. Mapping four corners(control points) $(x_1,y_1)$, $(x_2,y_2)$, $(x_3,y_3)$, $(x_4,y_4)$ in source image to $(u_1,v_1)$, $(u_2,v_2)$, $(u_3,v_3)$, $(u_4,v_4)$ in destination image with perspective transform, we get</p>
<p>$$\begin{bmatrix}<br>u_1\\v_1\\u_2\\v_2\\u_3\\v_3\\u_4\\v_4\\ \end{bmatrix} =<br>\begin{bmatrix}x_1&amp;y_1&amp;1&amp;0&amp;0&amp;0&amp;-u_1x_1&amp;-u_1y_1\\0&amp;0&amp;0&amp;x_1&amp;y_1&amp;1&amp;-v_1x_1&amp;-v_1y_1\\x_2&amp;y_2&amp;1&amp;0&amp;0&amp;0&amp;-u_2x_2&amp;-u_2y_2\\0&amp;0&amp;0&amp;x_2&amp;y_2&amp;2&amp;-v_2x_2&amp;-v_2y_2\\x_3&amp;y_3&amp;3&amp;0&amp;0&amp;0&amp;-u_3x_3&amp;-u_3y_3\\0&amp;0&amp;0&amp;x_3&amp;y_3&amp;1&amp;-v_3x_3&amp;-v_3y_3\\x_4&amp;y_4&amp;4&amp;0&amp;0&amp;0&amp;-u_4x_4&amp;-u_4y_4\\0&amp;0&amp;0&amp;x_4&amp;y_4&amp;1&amp;-v_4x_4&amp;-v_4y_4\\ \end{bmatrix}<br>\begin{bmatrix}a\\b\\c\\d\\e\\f\\m\\l\\<br>\end{bmatrix}$$</p>
<p>Or </p>
<p>$$UV=A\times M$$</p>
<p>Eight parameter in matrix form can be calculated by </p>
<p>$$M=A^{-1}\times UV$$</p>
<p><a name="ReverseMapping"></a></p>
<h3 id="Reverse-Mapping"><a href="#Reverse-Mapping" class="headerlink" title="Reverse Mapping"></a>Reverse Mapping</h3><p><strong>Forward Mapping(Bad):</strong> Iterate over source image, sending pixels to destination. With this method, many source pixels can map to same destination pixel and some destination pixels may not be covered.<br><img src="/images/paper-sheet/forward_mapping.jpg" alt=""><br><strong>Inverse Mapping(Better):</strong> Iterate over destination image, finding pixels from source. (x,y) does not usually have integer coordinates. Must resample source. May oversample, but much simpler! Pseudo-code:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> v = v_min to v_max</div><div class="line">    <span class="keyword">for</span> u = u_min to u_max</div><div class="line">        x = F(u, v); y = G(u, v)</div><div class="line">        copy pixel at source Src(x, y) to Dest(u, v)</div></pre></td></tr></table></figure>
<p>Here the F, G is the inverse transform of $u=\frac{ax+by+c}{mx+ly+1}, v=\frac{dx+ey+f}{mx+ly+1}$. Solve it and get</p>
<p>$$\begin{cases}<br>x=F(u,v)=\frac{(c-u)(vl-e)-(f-v)(ul-b)}{(um-a)(vl-e)-(vm-d)(ul-b)} \\[2ex]<br>y=G(u,v)=\frac{(c-u)(vm-d)-(f-v)(um-a)}{(ul-b)(vm-d)-(vl-e)(um-a)} \\[2ex]<br>\end{cases}$$</p>
<p><strong>Point Sampling with Bilinear Filter:</strong> weighted sum of four neighboring pixels.<br><img src="/images/paper-sheet/bilinear_filter.jpg" alt=""></p>
<p>$$Img_{dest}(x,y)=(1-a)(1-b)Img_{src}(i,j) + a(1-b)Img_{src}(i+1,j) + (1-a)b Img_{src}(i,j+1) + (1-a)(1-b)Img_{src}(i+1,j+1)$$</p>
<h2 id="Implementation-1"><a href="#Implementation-1" class="headerlink" title="Implementation"></a>Implementation</h2><h3 id="Environment"><a href="#Environment" class="headerlink" title="Environment"></a>Environment</h3><p>C++ language.</p>
<p><strong>Matrix operations</strong> implemented with <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" target="_blank" rel="external">Eigen</a> (a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms).<br><a href="http://eigen.tuxfamily.org/index.php?title=IDEs#Visual_Studio" target="_blank" rel="external">Using Eigen with Microsoft Visual Studio</a>: download (e.g. <a href="http://bitbucket.org/eigen/eigen/get/3.3.3.zip" target="_blank" rel="external">Eigen 3.3.3</a>), unpack in <code>EIGENDIR</code> (e.g. <code>F:\eigen3.3.3</code>),  add <code>EIGENDIR</code> in VS Project(<em>Project-&gt;Properties-&gt;C/C++-&gt;General-&gt;Additional Include Directories-&gt;F:\eigen3.3.3;</em>), include header file (e.g. <code>#include&lt;Eigen/Dense&gt;</code>), use(e.g. <code>Eigen::MatrixXf UV(8, 1);</code>).</p>
<p><strong>Image processing operations</strong> implemented with <a href="http://cimg.eu/" target="_blank" rel="external">The CImg Library</a>.<br>Usage: download <code>CImg.h</code> file, include by <code>include &quot;CImg.h&quot;</code></p>
<h3 id="Codes"><a href="#Codes" class="headerlink" title="Codes"></a>Codes</h3><ul>
<li>Step1: Before mapping, we need to get four control points in source image and destination image respectively. Destination corners can be easily defined</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">float</span> W = <span class="number">410</span>, H = <span class="number">594</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">float</span> u1 = <span class="number">0</span>, v1 = <span class="number">0</span>, <span class="comment">// top-left</span></div><div class="line">        u2 = W - <span class="number">1</span>, v2 = <span class="number">0</span>, <span class="comment">// top-right</span></div><div class="line">        u3 = <span class="number">0</span>, v3 = H - <span class="number">1</span>, <span class="comment">// bottom-left</span></div><div class="line">        u4 = W - <span class="number">1</span>, v4 = H - <span class="number">1</span>; <span class="comment">// bottom-right</span></div></pre></td></tr></table></figure>
<p>Source corners need to be in the same order as destination corners so as to map one by one correctly. The following method is a bit tricky and may not apply to all situations but for most of cases it works well.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Compare function for corners sort.The corner</span></div><div class="line">closest to original point rank first. */</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp_corners</span><span class="params">(Point c1, Point c2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (c1.x * c1.x + c1.y * c1.y)</div><div class="line">        &lt; (c2.x * c2.x + c2.y * c2.y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; Hough::getOrderedCorners() &#123;</div><div class="line">    <span class="comment">// Usually, if paper sheet is placed vertically(do not need strictly)</span></div><div class="line">    <span class="comment">// corners are ordered in top-left, top-right, bottom-left, bottom-right</span></div><div class="line">    <span class="comment">//  position by sorting (compare by the distance from original point)</span></div><div class="line">    sort(corners.begin(), corners.end(), cmp_corners);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; corners.size(); i += <span class="number">2</span>)</div><div class="line">        ordered_corners.push_back(Point(corners[i].x, corners[i].y));</div><div class="line">    </div><div class="line">    <span class="comment">// fine tuning the corners to white paper sheet if not</span></div><div class="line">    <span class="comment">// aims to crop black background</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> SHIFT = <span class="number">3</span>;</div><div class="line">    <span class="keyword">if</span> (rgb_img(ordered_corners[<span class="number">0</span>].x, ordered_corners[<span class="number">0</span>].y) &lt; <span class="number">125</span>) &#123;</div><div class="line">        ordered_corners[<span class="number">0</span>].x += SHIFT;</div><div class="line">        ordered_corners[<span class="number">0</span>].y += SHIFT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rgb_img(ordered_corners[<span class="number">1</span>].x, ordered_corners[<span class="number">1</span>].y) &lt; <span class="number">125</span>) &#123;</div><div class="line">        ordered_corners[<span class="number">1</span>].x -= SHIFT;</div><div class="line">        ordered_corners[<span class="number">1</span>].y += SHIFT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rgb_img(ordered_corners[<span class="number">2</span>].x, ordered_corners[<span class="number">2</span>].y) &lt; <span class="number">125</span>) &#123;</div><div class="line">        ordered_corners[<span class="number">2</span>].x += SHIFT;</div><div class="line">        ordered_corners[<span class="number">2</span>].y -= SHIFT;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rgb_img(ordered_corners[<span class="number">3</span>].x, ordered_corners[<span class="number">3</span>].y) &lt; <span class="number">125</span>) &#123;</div><div class="line">        ordered_corners[<span class="number">3</span>].x -= SHIFT;</div><div class="line">        ordered_corners[<span class="number">3</span>].y -= SHIFT;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// If horizontally, top-left and bottom-left corners,</span></div><div class="line">    <span class="comment">// top-right and bottom-tight corners need swapping.</span></div><div class="line">    <span class="comment">// If not, it seems like look from the back of the paper</span></div><div class="line">    <span class="comment">// I roughly judge it by image's width and height</span></div><div class="line">    <span class="comment">// but not paper sheet's for convenience.</span></div><div class="line">    <span class="keyword">if</span> (w &gt; h) &#123; </div><div class="line">        <span class="keyword">int</span> tmpx = ordered_corners[<span class="number">1</span>].x;</div><div class="line">        <span class="keyword">int</span> tmpy = ordered_corners[<span class="number">1</span>].y;</div><div class="line">        ordered_corners[<span class="number">1</span>].x = ordered_corners[<span class="number">0</span>].x;</div><div class="line">        ordered_corners[<span class="number">1</span>].y = ordered_corners[<span class="number">0</span>].y;</div><div class="line">        ordered_corners[<span class="number">0</span>].x = tmpx;</div><div class="line">        ordered_corners[<span class="number">0</span>].y = tmpy;</div><div class="line">        tmpx = ordered_corners[<span class="number">3</span>].x;</div><div class="line">        tmpy = ordered_corners[<span class="number">3</span>].y;</div><div class="line">        ordered_corners[<span class="number">3</span>].x = ordered_corners[<span class="number">2</span>].x;</div><div class="line">        ordered_corners[<span class="number">3</span>].y = ordered_corners[<span class="number">2</span>].y;</div><div class="line">        ordered_corners[<span class="number">2</span>].x = tmpx;</div><div class="line">        ordered_corners[<span class="number">2</span>].y = tmpy;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> ordered_corners;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Step2: calculate perspective transform parameters</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Warping::perspectiveTransform() &#123;</div><div class="line">    Eigen::<span class="function">MatrixXf <span class="title">UV</span><span class="params">(<span class="number">8</span>, <span class="number">1</span>)</span></span>;</div><div class="line">    Eigen::MatrixXf M = Eigen::MatrixXf::Constant(<span class="number">8</span>, <span class="number">1</span>, <span class="number">0</span>);</div><div class="line">    Eigen::<span class="function">MatrixXf <span class="title">A</span><span class="params">(<span class="number">8</span>, <span class="number">8</span>)</span></span>;</div><div class="line">    UV &lt;&lt; u1, v1, u2, v2, u3, v3, u4, v4;</div><div class="line">    A &lt;&lt; x1, y1, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -u1*x1, -u1*y1,</div><div class="line">         <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, x1, y1, <span class="number">1</span>, -v1*x1, -v1*y1,</div><div class="line">         x2, y2, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -u2*x2, -u2*y2,</div><div class="line">         <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, x2, y2, <span class="number">1</span>, -v2*x2, -v2*y2,</div><div class="line">         x3, y3, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -u3*x3, -u3*y3,</div><div class="line">         <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, x3, y3, <span class="number">1</span>, -v3*x3, -v3*y3,</div><div class="line">         x4, y4, <span class="number">1</span>, <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, -u4*x4, -u4*y4,</div><div class="line">         <span class="number">0</span>,  <span class="number">0</span>,  <span class="number">0</span>, x4, y4, <span class="number">1</span>, -v4*x4, -v4*y4;</div><div class="line">    M = A.inverse() * UV;</div><div class="line">    a = M(<span class="number">0</span>,<span class="number">0</span>), b = M(<span class="number">1</span>, <span class="number">0</span>), c = M(<span class="number">2</span>, <span class="number">0</span>), d = M(<span class="number">3</span>, <span class="number">0</span>),</div><div class="line">        e = M(<span class="number">4</span>, <span class="number">0</span>), f = M(<span class="number">5</span>, <span class="number">0</span>), m = M(<span class="number">6</span>, <span class="number">0</span>), l = M(<span class="number">7</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Step3: reverse mapping</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Warping::reverseMapping() &#123;</div><div class="line">    cimg_forXYC(dest_A4, u, v, c) &#123; <span class="comment">// c indicates color channels</span></div><div class="line">        <span class="keyword">float</span> x = getXTransformInv(u, v);</div><div class="line">        <span class="keyword">float</span> y = getYTransformInv(u, v);</div><div class="line">        dest_A4(u, v, c) = bilinearInterpolate(x, y, c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Auxiliary function</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">float</span> Warping::getXTransformInv(<span class="keyword">int</span> u, <span class="keyword">int</span> v) &#123;</div><div class="line">    <span class="keyword">return</span> ((c - u)*(v*l - e) - (f - v)*(u*l - b)) /</div><div class="line">        ((u*m - a)*(v*l - e) - (v*m - d)*(u*l - b));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">float</span> Warping::getYTransformInv(<span class="keyword">int</span> u, <span class="keyword">int</span> v) &#123;</div><div class="line">    <span class="keyword">return</span> ((c - u)*(v*m - d) - (f - v)*(u*m - a)) /</div><div class="line">        ((u*l - b)*(v*m - d) - (v*l - e)*(u*m - a));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">float</span> Warping::bilinearInterpolate(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">int</span> c) &#123;</div><div class="line">    <span class="keyword">int</span> i = floorf(x), j = floorf(y);</div><div class="line">    <span class="keyword">float</span> a = x - i, b = y - j;</div><div class="line">    <span class="keyword">return</span> (<span class="number">1</span> - a)*(<span class="number">1</span> - b)*src(i, j, c) + a*(<span class="number">1</span> - b)*src(i + <span class="number">1</span>, j, c)</div><div class="line">        + (<span class="number">1</span> - a)*b*src(i, j + <span class="number">1</span>, c) + a*b*src(i + <span class="number">1</span>, j + <span class="number">1</span>, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h1><p>All source images have resized to around 400px*539px, 631KB to save space and process time.<br>Following are original image, image with mark of edges and corners and cropped image respectively each row.</p>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/0.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/0_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/0_A4.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/1.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/1_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/1_A4.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/13.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/13_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/13_A4.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/3.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/3_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/3_A4.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/4.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/4_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/4_A4.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/5.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/5_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/5_A4.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/6.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/6_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/6_A4.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/7.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/7_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/7_A4.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/12.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/12_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/12_A4.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/9.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/9_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/9_A4.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/10.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/10_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/10_A4.bmp" alt=""></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/15.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/15_marked.bmp" alt=""></div><div class="group-picture-column" style="width: 33.333333333333336%;"><img src="/images/paper-sheet/15_A4.bmp" alt=""></div></div><div class="group-picture-row"></div></div></div>
<h2 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h2><p><strong>Pros:</strong> Most of the lines and corners are detected correctly in different circumstances(background, angle, noise, handwriting, light, shadow, imcomple paper sheet etc.) without tuning parameters for each image seperately.<br><strong>Cons:</strong> Cropped results is blureed due to bilinear interpolation. A few of the lines and corners are not aligned perfectly. There are several reasons:</p>
<ul>
<li>“Due to imperfection errors in the edge detection step, there will usually be errors in the accumulator space, which may make it non-trivial to find the appropriate peaks, and thus the appropriate lines.”</li>
<li>High-precision type like <code>double</code> is used for parameters like <code>m</code> and <code>b</code> while some parameters like <code>angle</code>, <code>rho</code> and cordinates of points have to use type like <code>int</code> for pixel by pixel calculation and storage in matrix. Error is produced when casting type.</li>
<li>The edges in images are not straight.</li>
</ul>
<p><a name="Improvement"></a></p>
<h2 id="Improvement"><a href="#Improvement" class="headerlink" title="Improvement"></a>Improvement</h2><h3 id="Using-the-gradient-direction-to-reduce-the-number-of-votes"><a href="#Using-the-gradient-direction-to-reduce-the-number-of-votes" class="headerlink" title="Using the gradient direction to reduce the number of votes"></a><a href="https://en.wikipedia.org/wiki/Hough_transform#Using_the_gradient_direction_to_reduce_the_number_of_votes" target="_blank" rel="external">Using the gradient direction to reduce the number of votes</a></h3><blockquote>
<p>An improvement suggested by O’Gorman and Clowes can be used to detect lines if one takes into account that <strong>the local gradient of the image intensity will necessarily be orthogonal to the edge</strong>. Since edge detection generally involves computing the intensity gradient magnitude, the gradient direction is often found as a side effect. If a given point of coordinates (x,y) happens to indeed be on a line, then the local direction of the gradient gives the θ parameter corresponding to said line, and the r parameter is then immediately obtained. (Shapiro and Stockman, 305) <strong>The gradient direction can be estimated to within 20°, which shortens the sinusoid trace from the full 180° to roughly 45°.</strong> This <em>reduces the computation time</em> and has the interesting effect of <em>reducing the number of useless votes</em>, thus <em>enhancing the visibility of the spikes corresponding to real lines</em> in the image.</p>
</blockquote>
<p>This can be easily implemented by calculate the <code>gradX</code> and <code>gradY</code> respectively and calculate the direction of gradient.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>


    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/03/19/dip-histogram-equalization/" rel="next" title="[DIP] Histogram Equalization on Grayscale and Color Image">
                <i class="fa fa-chevron-left"></i> [DIP] Histogram Equalization on Grayscale and Color Image
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/14/caffe-dnnh/" rel="prev" title="[Caffe] Similarity-Based Deep Neural Network Hashing">
                [Caffe] Similarity-Based Deep Neural Network Hashing <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

          
          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="HYPJUDY" />
          <p class="site-author-name" itemprop="name">HYPJUDY</p>
           
              <p class="site-description motion-element" itemprop="description">What I cannot create, I do not understand.</p>
          
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">posts</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/hypjudy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Edge-Detection-with-Hough-Transform"><span class="nav-number">1.</span> <span class="nav-text">Edge Detection with Hough Transform</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Theory"><span class="nav-number">1.1.</span> <span class="nav-text">Theory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation"><span class="nav-number">1.2.</span> <span class="nav-text">Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Init"><span class="nav-number">1.2.1.</span> <span class="nav-text">Init</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pre-treatment"><span class="nav-number">1.2.2.</span> <span class="nav-text">Pre-treatment</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transform-to-Hough-Space"><span class="nav-number">1.3.</span> <span class="nav-text">Transform to Hough Space</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Looking-for-Local-Maxima-in-Hough-Space"><span class="nav-number">1.3.1.</span> <span class="nav-text">Looking for Local Maxima in Hough Space</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-Lines"><span class="nav-number">1.3.2.</span> <span class="nav-text">Find Lines</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Find-Corners"><span class="nav-number">1.3.3.</span> <span class="nav-text">Find Corners</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Display-Corners-and-Lines"><span class="nav-number">1.3.4.</span> <span class="nav-text">Display Corners and Lines</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A-Typical-Example"><span class="nav-number">1.4.</span> <span class="nav-text">A Typical Example</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Image-Warping-and-Perspective-Transform-of-2D-Image"><span class="nav-number">2.</span> <span class="nav-text">Image Warping and Perspective Transform of 2D Image</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Theory-1"><span class="nav-number">2.1.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">2.1.1.</span> <span class="nav-text">Reference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Concepts"><span class="nav-number">2.1.2.</span> <span class="nav-text">Concepts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Perspective-Transform-Parameters-Calculation"><span class="nav-number">2.1.3.</span> <span class="nav-text">Perspective Transform Parameters Calculation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reverse-Mapping"><span class="nav-number">2.1.4.</span> <span class="nav-text">Reverse Mapping</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementation-1"><span class="nav-number">2.2.</span> <span class="nav-text">Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Environment"><span class="nav-number">2.2.1.</span> <span class="nav-text">Environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Codes"><span class="nav-number">2.2.2.</span> <span class="nav-text">Codes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Results"><span class="nav-number">3.</span> <span class="nav-text">Results</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pros-and-Cons"><span class="nav-number">3.1.</span> <span class="nav-text">Pros and Cons</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Improvement"><span class="nav-number">3.2.</span> <span class="nav-text">Improvement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-the-gradient-direction-to-reduce-the-number-of-votes"><span class="nav-number">3.2.1.</span> <span class="nav-text">Using the gradient direction to reduce the number of votes</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HYPJUDY</span>
</div>


<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'hypjudy';
      var disqus_identifier = '2017/03/28/cvpr-A4-paper-sheet-detection-and-cropping/';

      var disqus_title = "[CVPR] A4 Paper Sheet Detection and Cropping with Hough Transform and Warping";


      function run_disqus_script(disqus_script) {
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');

      
        var disqus_config = function () {
            this.page.url = disqus_url;
            this.page.identifier = disqus_identifier;
            this.page.title = disqus_title;
        };
        run_disqus_script('embed.js');
      

    </script>
  










  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


  

</body>
</html>
